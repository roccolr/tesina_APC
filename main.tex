%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lachaise Assignment
% LaTeX Template
% Version 1.0 (26/6/2018)
%
% This template originates from:
% http://www.LaTeXTemplates.com
%
% Authors:
% Marion Lachaise & François Févotte
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\input{structure.tex} % Include the file specifying the document structure and custom commands

%----------------------------------------------------------------------------------------
%	ASSIGNMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{Prova 22/05/2025} % Title of the assignment

\author{Rocco Lo Russo\\ \texttt{roc.lorusso@studenti.unina.it}} % Author name and email address

\date{Università di Napoli Federico II - DIETI --- \today} % University, school and/or department name(s) and a date

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

\section*{Introduzione} % Unnumbered section
In questo documento verrà sviluppata la prova intercorso del 22/05/2025, esponendo analiticamente i seguenti punti: \textbf{mappa della memoria}, \textbf{pseudocodice} e implementazione in \textbf{ASIM}.

% Math equation/formula
% \begin{equation}
% 	I = \int_{a}^{b} f(x) \; \text{d}x.
% \end{equation}

% Aliquam arcu turpis, ultrices sed luctus ac, vehicula id metus. Morbi eu feugiat velit, et tempus augue. Proin ac mattis tortor. Donec tincidunt, ante rhoncus luctus semper, arcu lorem lobortis justo, nec convallis ante quam quis lectus. Aenean tincidunt sodales massa, et hendrerit tellus mattis ac. Sed non pretium nibh. Donec cursus maximus luctus. Vivamus lobortis eros et massa porta porttitor.

% \begin{info} % Information block
% 	This is an interesting piece of information, to which the reader should pay special attention. Fusce varius orci ac magna dapibus porttitor. In tempor leo a neque bibendum sollicitudin. Nulla pretium fermentum nisi, eget sodales magna facilisis eu. Praesent aliquet nulla ut bibendum lacinia. Donec vel mauris vulputate, commodo ligula ut, egestas orci. Suspendisse commodo odio sed hendrerit lobortis. Donec finibus eros erat, vel ornare enim mattis et.
% \end{info}

%----------------------------------------------------------------------------------------
%	PROBLEM 1
%----------------------------------------------------------------------------------------

\section{Traccia} \label{sec:traccia}% Numbered section 

Un sistema è composto da 3 unità, A, B e C, tra loro collegate mediante due periferiche parallele che interconnettono A con B e A con C rispettivamente. I messaggi hanno un primo carattere identificativo che può essere pari a 0 a un valore diverso da 0. Il sistema opera in due fasi successive come descritto di seguito:
\begin{itemize}
	\item Fase 1: A riceve K messaggi di N caratteri da B e da C in modo alternato. In ordine non prefissato, quindi si parte da B o da C, e \textbf{non ci sono sovrapposizioni tra i messaggi ricevuti da B o da C};
	\item Fase 2: Al termine della fase 1, il nodo A continua nella stessa modalità alternata e termina la ricezione dei messaggi se due messaggi ricevuti (dalle due diverse periferiche) hanno il carattere identificativo del messaggio pari a 0.
\end{itemize}

%------------------------------------------------

\subsection{Analisi della traccia}
Dalla traccia emerge che la comunicazione debba essere gestita in modo tale da garantire la \textit{non sovrapposizione} dei messaggi ricevuti da B e da C. Questo implica che verrà utilizzato un unico buffer di ricezione in cui verranno conservati i messaggi ricevuti, e che una periferica non potrà mandare un nuovo carattere se l'altra non avrà finito la trasmissione di un intero messaggio. La ricezione dei messaggi in modo alternato pone il vincolo, nella codifica della ISR, di considerare casuale la provenienza del primo messaggio. Ci sono due modi di interpretare questo passo della traccia:
\begin{itemize}
	\item Il primo messaggio può arrivare da qualsiasi periferica, e una volta arrivato questo stabilisce l'ordine di arrivo di tutti gli altri K-1 messaggi;
	\item I messaggi vengono ricevuti in modo alternato ma a coppie, ovvero \textbf{per ogni coppia} il primo messaggio può provenire da qualsiasi periferica, ma il secondo deve provenire necessariamente dall'altra.
\end{itemize}
La soluzione presentata più avanti si basa sulla seconda interpretazione. Sotto questi vincoli, i conflitti da gestire sono:
\begin{itemize}
	\item Accesso in mutua esclusione in scrittura alla risorsa rappresentata dal nodo A, in modo da garantire la non sovrapposizione dei messaggi;
	\item Regolare l'accesso alla risorsa in modo che sia alternato, curando i casi in cui le ISR pongano una periferica in stato di attesa. 
\end{itemize}

% Numbered question, with subquestions in an enumerate environment
% \begin{question}
% 	Quisque ullamcorper placerat ipsum. Cras nibh. Morbi vel justo vitae lacus tincidunt ultrices. Lorem ipsum dolor sit amet, consectetuer adipiscing elit.

% 	% Subquestions numbered with letters
% 	\begin{enumerate}[(a)]
% 		\item Do this.
% 		\item Do that.
% 		\item Do something else.
% 	\end{enumerate}
% \end{question}
	
%------------------------------------------------

% \subsection{Algorithmic issues}

% In malesuada ullamcorper urna, sed dapibus diam sollicitudin non. Donec elit odio, accumsan ac nisl a, tempor imperdiet eros. Donec porta tortor eu risus consequat, a pharetra tortor tristique. Morbi sit amet laoreet erat. Morbi et luctus diam, quis porta ipsum. Quisque libero dolor, suscipit id facilisis eget, sodales volutpat dolor. Nullam vulputate interdum aliquam. Mauris id convallis erat, ut vehicula neque. Sed auctor nibh et elit fringilla, nec ultricies dui sollicitudin. Vestibulum vestibulum luctus metus venenatis facilisis. Suspendisse iaculis augue at vehicula ornare. Sed vel eros ut velit fermentum porttitor sed sed massa. Fusce venenatis, metus a rutrum sagittis, enim ex maximus velit, id semper nisi velit eu purus.

% \begin{center}
% 	\begin{minipage}{0.5\linewidth} % Adjust the minipage width to accomodate for the length of algorithm lines
% 		\begin{algorithm}[H]
% 			\KwIn{$(a, b)$, two floating-point numbers}  % Algorithm inputs
% 			\KwResult{$(c, d)$, such that $a+b = c + d$} % Algorithm outputs/results
% 			\medskip
% 			\If{$\vert b\vert > \vert a\vert$}{
% 				exchange $a$ and $b$ \;
% 			}
% 			$c \leftarrow a + b$ \;
% 			$z \leftarrow c - a$ \;
% 			$d \leftarrow b - z$ \;
% 			{\bf return} $(c,d)$ \;
% 			\caption{\texttt{FastTwoSum}} % Algorithm name
% 			\label{alg:fastTwoSum}   % optional label to refer to
% 		\end{algorithm}
% 	\end{minipage}
% \end{center}

% Fusce varius orci ac magna dapibus porttitor. In tempor leo a neque bibendum sollicitudin. Nulla pretium fermentum nisi, eget sodales magna facilisis eu. Praesent aliquet nulla ut bibendum lacinia. Donec vel mauris vulputate, commodo ligula ut, egestas orci. Suspendisse commodo odio sed hendrerit lobortis. Donec finibus eros erat, vel ornare enim mattis et.

% % Numbered question, with an optional title
% \begin{question}[\itshape (with optional title)]
% 	In congue risus leo, in gravida enim viverra id. Donec eros mauris, bibendum vel dui at, tempor commodo augue. In vel lobortis lacus. Nam ornare ullamcorper mauris vel molestie. Maecenas vehicula ornare turpis, vitae fringilla orci consectetur vel. Nam pulvinar justo nec neque egestas tristique. Donec ac dolor at libero congue varius sed vitae lectus. Donec et tristique nulla, sit amet scelerisque orci. Maecenas a vestibulum lectus, vitae gravida nulla. Proin eget volutpat orci. Morbi eu aliquet turpis. Vivamus molestie urna quis tempor tristique. Proin hendrerit sem nec tempor sollicitudin.
% \end{question}

% Mauris interdum porttitor fringilla. Proin tincidunt sodales leo at ornare. Donec tempus magna non mauris gravida luctus. Cras vitae arcu vitae mauris eleifend scelerisque. Nam sem sapien, vulputate nec felis eu, blandit convallis risus. Pellentesque sollicitudin venenatis tincidunt. In et ipsum libero. Nullam tempor ligula a massa convallis pellentesque.

%----------------------------------------------------------------------------------------
%	PROBLEM 2
%----------------------------------------------------------------------------------------

\section{Mappa della memoria}
In questa sezione verrà presentata una mappa della memoria del nodo A in accordo a quanto specificato nel file .cfg utilizzato nella simulazione.

\begin{center}
    
    \begin{tikzpicture}[scale=1]
        % Rettangolo principale
        \draw (0,0) rectangle (5,8);
        \node at (2.5,8.3) {\textbf{Memory Map}};
        
        % Code segment
        \draw (0,7) rectangle (5,8);
        \node[left=5pt] at (0,7.5) {Code Segment};
        \node[right=5pt] at (5,7.5) {\texttt{0x0000}};
        
        % Data segment
        \draw (0,5) rectangle (5,7);
        \node[left=5pt] at (0,6) {Data Segment};
        \node[right=5pt] at (5,6) {\texttt{0x2000}};
        
        % Heap
        \draw (0,3) rectangle (5,5);
        \node[left=5pt] at (0,4) {Heap};
        \node[right=5pt] at (5,4) {\texttt{0x4000}};
        
        % Stack
        \draw (0,0) rectangle (5,3);
        \node[left=5pt] at (0,1.5) {Stack};
        \node[right=5pt] at (5,1.5) {\texttt{0x6000}};
    \end{tikzpicture}
\end{center}
% Proin lobortis efficitur dictum. Pellentesque vitae pharetra eros, quis dignissim magna. Sed tellus leo, semper non vestibulum vel, tincidunt eu mi. Aenean pretium ut velit sed facilisis. Ut placerat urna facilisis dolor suscipit vehicula. Ut ut auctor nunc. Nulla non massa eros. Proin rhoncus arcu odio, eu lobortis metus sollicitudin eu. Duis maximus ex dui, id bibendum diam dignissim id. Aliquam quis lorem lorem. Phasellus sagittis aliquet dolor, vulputate cursus dolor convallis vel. Suspendisse eu tellus feugiat, bibendum lectus quis, fermentum nunc. Nunc euismod condimentum magna nec bibendum. Curabitur elementum nibh eu sem cursus, eu aliquam leo rutrum. Sed bibendum augue sit amet pharetra ullamcorper. Aenean congue sit amet tortor vitae feugiat.

% In congue risus leo, in gravida enim viverra id. Donec eros mauris, bibendum vel dui at, tempor commodo augue. In vel lobortis lacus. Nam ornare ullamcorper mauris vel molestie. Maecenas vehicula ornare turpis, vitae fringilla orci consectetur vel. Nam pulvinar justo nec neque egestas tristique. Donec ac dolor at libero congue varius sed vitae lectus. Donec et tristique nulla, sit amet scelerisque orci. Maecenas a vestibulum lectus, vitae gravida nulla. Proin eget volutpat orci. Morbi eu aliquet turpis. Vivamus molestie urna quis tempor tristique. Proin hendrerit sem nec tempor sollicitudin.

% % File contents
% \begin{file}[hello.py]
% \begin{lstlisting}[language=Python]
% #! /usr/bin/python

% import sys
% sys.stdout.write("Hello World!\n")
% \end{lstlisting}
% \end{file}

% Fusce eleifend porttitor arcu, id accumsan elit pharetra eget. Mauris luctus velit sit amet est sodales rhoncus. Donec cursus suscipit justo, sed tristique ipsum fermentum nec. Ut tortor ex, ullamcorper varius congue in, efficitur a tellus. Vivamus ut rutrum nisi. Phasellus sit amet enim efficitur, aliquam nulla id, lacinia mauris. Quisque viverra libero ac magna maximus efficitur. Interdum et malesuada fames ac ante ipsum primis in faucibus. Vestibulum mollis eros in tellus fermentum, vitae tristique justo finibus. Sed quis vehicula nibh. Etiam nulla justo, pellentesque id sapien at, semper aliquam arcu. Integer at commodo arcu. Quisque dapibus ut lacus eget vulputate.

% % Command-line "screenshot"
% \begin{commandline}
% 	\begin{verbatim}
% 		$ chmod +x hello.py
% 		$ ./hello.py

% 		Hello World!
% 	\end{verbatim}
% \end{commandline}

% Vestibulum sodales orci a nisi interdum tristique. In dictum vehicula dui, eget bibendum purus elementum eu. Pellentesque lobortis mattis mauris, non feugiat dolor vulputate a. Cras porttitor dapibus lacus at pulvinar. Praesent eu nunc et libero porttitor malesuada tempus quis massa. Aenean cursus ipsum a velit ultricies sagittis. Sed non leo ullamcorper, suscipit massa ut, pulvinar erat. Aliquam erat volutpat. Nulla non lacus vitae mi placerat tincidunt et ac diam. Aliquam tincidunt augue sem, ut vestibulum est volutpat eget. Suspendisse potenti. Integer condimentum, risus nec maximus elementum, lacus purus porta arcu, at ultrices diam nisl eget urna. Curabitur sollicitudin diam quis sollicitudin varius. Ut porta erat ornare laoreet euismod. In tincidunt purus dui, nec egestas dui convallis non. In vestibulum ipsum in dictum scelerisque.

% Warning text, with a custom title
% \begin{warn}[Osservazione:]
%   In congue risus leo, in gravida enim viverra id. Donec eros mauris, bibendum vel dui at, tempor commodo augue. In vel lobortis lacus. Nam ornare ullamcorper mauris vel molestie. Maecenas vehicula ornare turpis, vitae fringilla orci consectetur vel. Nam pulvinar justo nec neque egestas tristique. Donec ac dolor at libero congue varius sed vitae lectus. Donec et tristique nulla, sit amet scelerisque orci. Maecenas a vestibulum lectus, vitae gravida nulla. Proin eget volutpat orci. Morbi eu aliquet turpis. Vivamus molestie urna quis tempor tristique. Proin hendrerit sem nec tempor sollicitudin.
% \end{warn}

%----------------------------------------------------------------------------------------

\section{Implementazione}
In questa sezione verrà presentato il codice assembly per Motorola68000 e lo pseudocodice usato come riferimento per l'implementazione.

\subsection{Variabili}
Descrizione delle variabili utilizzate: 
\\

\begin{description}[style=nextline,leftmargin=3.45cm,labelwidth=2.8cm,labelsep=0.6cm,font=\ttfamily\bfseries]
  \item[fine] Intero che può assumere i valori 0 (il nodo A è in ricezione) o 1 (il nodo A ha terminato la ricezione).
  \item[lock] Intero che può assumere i valori 0 o 1, viene testato dall'istruzione atomica LOCK per garantire l'accesso mutualmente esclusivo alla sezione critica.
  \item[possesso] Intero che può assumere i valori -1 (\texttt{is\_free}), 0 (\texttt{is\_reading\_b}) o 1 (\texttt{is\_reading\_c}).
  \item[buff] Puntatore alla prima locazione di un vettore di dimensione K*N di caratteri; serve per accedere alla memoria del nodo A.
  \item[curr] Variabile intera da 0 a N che tiene conto dei caratteri ricevuti.
  \item[tot] Intero da 0 a K*N per l’accesso indirizzato al vettore dei caratteri.
  \item[msg] Intero da 0 a K che conta i messaggi ricevuti.
  \item[end\_b,(end\_c)] Intero: 0 se il messaggio da b (c) non è terminato, 1 altrimenti.
  \item[fase2] Intero: 0 (fase 1), 1 (fase 2).
  \item[cond\_b,(cond\_c)] Intero: 0 se il primo carattere ricevuto da b (c) non è 0, 1 altrimenti.
  \item[b\_sus,(c\_sus)] Intero: 0 se b (c) non è bloccato, 1 se è in attesa che venga letto il carattere.
  \item[idx] Variabile temporanea per memorizzare un valore della variabile \texttt{tot}.
\end{description}

\subsection{Pseudocodice}
Assumiamo che ISR\_B e ISR\_C siano speculari, e che ISR\_B sia più prioritaria di ISR\_C : se il nodo A riceve un messaggio da C durante l'esecuzione di ISR\_B, ISR\_C prelaziona ISR\_B. Come anticipato nella sezione \ref{sec:traccia}, l'accesso alla sezione critica in cui si controlla ed eventualmente modifica la variabile \textit{possesso} avverrà in mutua esclusione.

\vspace{2\baselineskip}
\begin{lstlisting}
# define is_reading_b 0
# define is_reading_c 1
# define is_free -1 

void isr_b(){
    if(!fine){
        if(TAS(lock)){
            if(possesso !=c and !end_b){
                possesso = is_reading_b;
            }
            lock = 0;
        }else{
            RTE;
        }

        switch (possesso){
            case is_reading_b:
                buff[tot] = PIABPRA;
                if(curr == 0 && fase2 && buff[tot] == 0){
                    cond_b = 1;
                }
                tot++;
                curr++;
                if(curr == N){
                    curr = 0;
                    msg++;
                    end_b = 1;
                    possesso = is_free;
                    if(end_c){
                        end_b = 0;
                        end_c = 0;
                        if(msg==k){
                            fase2=1;
                        }
                    }
                    if(fase2 && (cond_b && cond_c)){
                        fine = 1;
                    }
                    if(c_sus && !end_c){
                        tot++;
                        curr++;
                        buff[tot-1] = PIACPRA;
                        // se c interrompe qui, trovera' possesso=is_free
                        if(buff[tot-1] == 0 && fase2){
                            cond_c=1;
                        }
                        possesso = is_reading_c;
                    }
                }
             case is_free:
                if(c_sus && !end_c){
                    tot++;
                    curr++;
                    buff[tot-1] = PIACPRA;
                    if(buff[tot-1] == 0 && fase2){
                        cond_c=1;
                    }
                    possesso = is_reading_c;
                }
            case is_reading_c{
                if(c_sus){
                // L'unica assunzione possibile e' che 
                // questo non sia il primo carattere di b
                    idx = tot;
                    tot++;
                    curr++;
                    possesso = is_reading_c;
                    if(curr == N){
                        curr = 0;
                        msg++;
                        end_c = 1;
                        possesso = is_free;
                        if (end_b){
                            end_b = 0;
                            end_c = 0;
                            msg++;
                            if(msg == k){
                                fase2=1;
                            }
                        }
                        if(fase2 && (cond_b && cond_c)){
                            fine = 1;
                        }
                        if(!end_b){
                            buff[tot]=PIABPRA;
                            tot++;
                            curr++;
                            if(fase2 && buff[tot-1]==0){
                                cond_b = 1;
                            }
                            possesso = is_reading_b;
                        }
                    }
                    buff[idx]=PIACPRA;
                }
            }
        }   
        RTE;
    }else{  // se fine == 1
        RTE;
    }
} // fine isr_b 
\end{lstlisting}

\end{document}
